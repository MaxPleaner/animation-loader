// Generated by CoffeeScript 2.0.0-alpha1
(function() {
  var DeferMerge, asset_dir, build_bg_frame_ranges, compile_video, exec_sync, file_ready, fs, gen_path, gen_tmp_png_path, get_num_frames, loader_utils, querystring_parser, randomstring, to_merged, to_resized, to_transparent_gif, to_webm_alpha;

  require('colors');

  loader_utils = require('loader-utils');

  exec_sync = require('child_process').execSync;

  querystring_parser = require('querystring');

  randomstring = require('randomstring');

  fs = require('fs');

  asset_dir = "./.animation-loader";

  exec_sync(`rm -rf ${asset_dir}\nmkdir -p ${asset_dir}\ntouch .merge.gif`);

  gen_path = function(extension) {
    return `${asset_dir}/${randomstring.generate()}.${extension}`;
  };

  gen_tmp_png_path = function() {
    return `${asset_dir}/${randomstring.generate()}%03d.png`;
  };

  to_transparent_gif = function(in_gif_path, color, fuzz) {
    var cmd, new_path;
    console.log("making transparent".yellow);
    fuzz || (fuzz = 25);
    color || (color = "000000");
    new_path = gen_path("gif");
    cmd = `convert ${in_gif_path} -coalesce -fuzz ${fuzz}% -transparent \"#${color}\" miff:- | convert -dispose background - ${new_path}`;
    exec_sync(cmd);
    exec_sync(`rm ${in_gif_path}`);
    return new_path;
  };

  to_resized = function(in_gif_path, new_size) {
    var new_path;
    console.log("resizing".yellow);
    new_path = gen_path("gif");
    exec_sync(`convert ${in_gif_path} -coalesce -resize ${new_size}! ${new_path}`);
    exec_sync(`rm ${in_gif_path}`);
    return new_path;
  };

  to_webm_alpha = function(in_gif_path) {
    var new_path, tmp_png_path;
    new_path = gen_path("webm");
    tmp_png_path = gen_tmp_png_path();
    console.log("converting to webm - creating png frames".yellow);
    exec_sync(`convert ${in_gif_path} -coalesce ${tmp_png_path}`);
    console.log("converting to webm - combining frames".yellow);
    exec_sync(`ffmpeg -f image2 -i ${tmp_png_path} -c:v libvpx -pix_fmt yuva420p ${new_path}\nrm ${asset_dir}/*png`);
    exec_sync(`rm ${in_gif_path}`);
    return new_path;
  };

  get_num_frames = function(path) {
    var frames_text, num_frames;
    frames_text = exec_sync(`identify -format '%T,%w,%h ' \"${path}\"`).toString();
    num_frames = frames_text.split(" ").length;
    return num_frames;
  };

  build_bg_frame_ranges = function(bg_frames, fg_frames) {
    var full_bg, full_loops, i, remainder, result, results;
    if (fg_frames < bg_frames) {
      return `0-${fg_frames - 2}`;
    } else {
      full_bg = `0-${bg_frames - 1}`;
      full_loops = Math.floor(fg_frames / bg_frames);
      remainder = fg_frames % bg_frames;
      result = ((function() {
        results = [];
        for (var i = 0; 0 <= full_loops ? i < full_loops : i > full_loops; 0 <= full_loops ? i++ : i--){ results.push(i); }
        return results;
      }).apply(this).map(() => {
        return full_bg;
      })).join(",");
      if (remainder > 0) {
        if (full_loops > 0) {
          result += ",";
        }
        result += `0-${remainder - 1}`;
      }
      return result;
    }
  };

  DeferMerge = function() {};

  DeferMerge.prototype = new Error();

  file_ready = function(path) {
    return fs.existsSync(path);
  };

  to_merged = function(arg) {
    var background, bg_frame_ranges, bg_frames, bg_path, fg_frames, fg_path, foreground, new_path, new_path_2, ref, size, tmp1, tmp2;
    background = arg.background, foreground = arg.foreground, size = arg.size;
    new_path = gen_path("gif");
    ref = (function() {
      var i, results;
      results = [];
      for (i = 1; i <= 2; i++) {
        results.push(gen_path("png"));
      }
      return results;
    })(), tmp1 = ref[0], tmp2 = ref[1];
    bg_path = `${asset_dir}/${background}.gif`;
    fg_path = `${asset_dir}/${foreground}.gif`;
    if (!([bg_path, fg_path].every(file_ready))) {
      console.log("deferring merge".yellow);
      throw new DeferMerge;
    }
    bg_frames = get_num_frames(bg_path);
    fg_frames = get_num_frames(fg_path);
    bg_frame_ranges = build_bg_frame_ranges(bg_frames, fg_frames);
    console.log(`merging \n  bg: ${background}(${bg_frame_ranges}) \n  fg: ${foreground}(${fg_frames})`.blue);
    exec_sync(`montage                        -background none             ${fg_path}                   -tile x1@ -geometry +0+0     ${tmp1}\n\nmontage                        ${bg_path}[${bg_frame_ranges}] -tile x1@ -geometry +0+0     ${tmp2}\n\nconvert                             -delay 10 -loop 0 ${tmp2} ${tmp1} -coalesce -flatten                -crop ${size} +repage             ${new_path}\n\nrm ${tmp1} ${tmp2}`);
    new_path_2 = gen_path("gif");
    exec_sync(`convert ${new_path}[0-${fg_frames - 2}] ${new_path_2}\nrm ${new_path}`);
    return new_path_2;
  };

  compile_video = function(remaining_request) {
    var background, color, error, ext, failed, foreground, full_path, fuzz, merge, name, new_path, path, query, querystring, ref, resize, size, to_webm, transparent;
    failed = false;
    ref = remaining_request.split("?"), full_path = ref[0], querystring = ref[1];
    query = querystring_parser.parse(querystring);
    merge = full_path.endsWith(".merge.gif");
    path = `${asset_dir}/${randomstring.generate()}.gif`;
    if (!merge) {
      exec_sync(`cp ${full_path} ${path}`);
    }
    console.log(`compiling gif: ${full_path} with params:`.yellow);
    console.log(query);
    transparent = query.transparent, resize = query.resize, to_webm = query.to_webm, color = query.color, fuzz = query.fuzz, background = query.background, foreground = query.foreground, size = query.size, name = query.name;
    try {
      if (merge) {
        path = to_merged({
          background: background,
          foreground: foreground,
          size: size
        });
      }
    } catch (error1) {
      error = error1;
      if (error instanceof DeferMerge) {
        failed = true;
      } else {
        throw error;
      }
    }
    if (failed) {
      return;
    }
    if (resize) {
      path = to_resized(path, resize);
    }
    if (transparent) {
      path = to_transparent_gif(path, color, fuzz);
    }
    if (to_webm) {
      path = to_webm_alpha(path);
    }
    if (name) {
      ext = to_webm ? "webm" : "gif";
      new_path = `${asset_dir}/${name}.${ext}`;
      if (fs.existsSync(new_path)) {
        exec_sync(`rm ${new_path}`);
      }
      exec_sync(`mv ${path} ${new_path}`);
      path = new_path;
    }
    return path;
  };

  module.exports = function(source) {
    var remaining_request, result;
    this.cachable && this.cachable();
    remaining_request = loader_utils.getRemainingRequest(this);
    result = compile_video(remaining_request);
    if (result) {
      return this.callback(null, result);
    }
  };

}).call(this);
