// Generated by CoffeeScript 2.0.0-alpha1
(function() {
  var asset_dir, build_frames_ranges, compile_video, exec_sync, gen_path, gen_tmp_png_path, get_num_frames, loader_utils, querystring_parser, randomstring, to_merged, to_resized, to_transparent_gif, to_webm_alpha;

  require('colors');

  loader_utils = require('loader-utils');

  exec_sync = require('child_process').execSync;

  querystring_parser = require('querystring');

  randomstring = require('randomstring');

  asset_dir = ".animation-loader";

  exec_sync(`rm -rf ${asset_dir}\nmkdir -p ${asset_dir}\ntouch .merge.gif`);

  gen_path = function(extension) {
    return `${asset_dir}/${randomstring.generate()}.${extension}`;
  };

  gen_tmp_png_path = function() {
    return `${asset_dir}/${randomstring.generate()}%03d.png`;
  };

  global.animation_loader_named_paths = {};

  to_transparent_gif = function(in_gif_path, color, fuzz) {
    var cmd, new_path;
    console.log("making transparent".yellow);
    fuzz || (fuzz = 25);
    color || (color = "000000");
    new_path = gen_path("gif");
    cmd = `convert ${in_gif_path} -coalesce -fuzz ${fuzz}% -transparent \"#${color}\" miff:- | convert -dispose background - ${new_path}`;
    exec_sync(cmd);
    exec_sync(`rm ${in_gif_path}`);
    return new_path;
  };

  to_resized = function(in_gif_path, new_size) {
    var new_path;
    console.log("resizing".yellow);
    new_path = gen_path("gif");
    exec_sync(`convert ${in_gif_path} -coalesce -resize ${new_size}! ${new_path}`);
    exec_sync(`rm ${in_gif_path}`);
    return new_path;
  };

  to_webm_alpha = function(in_gif_path) {
    var new_path, tmp_png_path;
    new_path = gen_path("webm");
    tmp_png_path = gen_tmp_png_path();
    console.log("converting to webm - creating png frames".yellow);
    exec_sync(`convert ${in_gif_path} -coalesce ${tmp_png_path}`);
    console.log("converting to webm - combining frames".yellow);
    exec_sync(`ffmpeg -f image2 -i ${tmp_png_path} -c:v libvpx -pix_fmt yuva420p ${new_path}\nrm ${asset_dir}/*png`);
    exec_sync(`rm ${in_gif_path}`);
    return new_path;
  };

  get_num_frames = function(path) {
    var frames_text, num_frames;
    frames_text = exec_sync(`identify -format '%T,%w,%h ' \"${path}\"`).toString();
    num_frames = frames_text.split(" ").length;
    return num_frames;
  };

  build_frames_ranges = function(bg_frames, fg_frames) {
    var full_bg, full_loops, i, remainder, result, results;
    if (fg_frames < bg_frames) {
      return `0-${fg_frames - 1}`;
    } else {
      full_bg = `0-${bg_frames - 1}`;
      full_loops = Math.floor(fg_frames / bg_frames);
      remainder = fg_frames % bg_frames;
      result = ((function() {
        results = [];
        for (var i = 0; 0 <= full_loops ? i < full_loops : i > full_loops; 0 <= full_loops ? i++ : i--){ results.push(i); }
        return results;
      }).apply(this).map(() => {
        return full_bg;
      })).join(",");
      if (remainder > 0) {
        if (full_loops > 0) {
          result += ",";
        }
        result += `0-${remainder - 1}`;
      }
      return result;
    }
  };

  to_merged = function(arg) {
    var background, bg_frames, bg_path, fg_frames, fg_path, foreground, frames_ranges, new_path, ref, size, tmp1, tmp2;
    background = arg.background, foreground = arg.foreground, size = arg.size;
    console.log("merging".yellow);
    new_path = gen_path("gif");
    ref = (function() {
      var i, results;
      results = [];
      for (i = 1; i <= 2; i++) {
        results.push(gen_path("png"));
      }
      return results;
    })(), tmp1 = ref[0], tmp2 = ref[1];
    bg_path = animation_loader_named_paths[background];
    fg_path = animation_loader_named_paths[foreground];
    if (!(bg_path && fg_path)) {
      console.log("deferring merge".yellow);
      throw "not really an error";
    }
    bg_frames = get_num_frames(bg_path);
    fg_frames = get_num_frames(fg_path);
    frames_ranges = build_frames_ranges(bg_frames, fg_frames);
    exec_sync(`montage -background none ${fg_path} -tile x1@ -geometry +0+0 ${tmp1}\nmontage ${bg_path}[${frames_ranges}] -tile x1@ -geometry +0+0 ${tmp2}\nconvert                             -delay 10 -loop 0 ${tmp2} ${tmp1} -coalesce -flatten                -crop ${size} +repage             ${new_path}\nrm ${tmp1} ${tmp2}`);
    return new_path;
  };

  compile_video = function(remaining_request) {
    var background, color, error, ext, failed, foreground, full_path, fuzz, merge, name, new_path, path, query, querystring, ref, resize, size, to_webm, transparent;
    failed = false;
    ref = remaining_request.split("?"), full_path = ref[0], querystring = ref[1];
    query = querystring_parser.parse(querystring);
    merge = full_path.endsWith(".merge.gif");
    path = `${asset_dir}/${randomstring.generate()}.gif`;
    exec_sync(`cp ${full_path} ${path}`);
    console.log(`compiling gif: ${full_path} with params:`.yellow);
    console.log(query);
    transparent = query.transparent, resize = query.resize, to_webm = query.to_webm, color = query.color, fuzz = query.fuzz, background = query.background, foreground = query.foreground, size = query.size, name = query.name;
    try {
      if (merge) {
        path = to_merged({
          background: background,
          foreground: foreground,
          size: size
        });
      }
    } catch (error1) {
      error = error1;
      failed = true;
    }
    if (failed) {
      return;
    }
    if (resize) {
      path = to_resized(path, resize);
    }
    if (transparent) {
      path = to_transparent_gif(path, color, fuzz);
    }
    if (to_webm) {
      path = to_webm_alpha(path);
    }
    console.log("done".green);
    if (name) {
      ext = to_webm ? "webm" : "gif";
      new_path = `${asset_dir}/${name}.${ext}`;
      exec_sync(`mv ${path} ${new_path}`);
      path = new_path;
      animation_loader_named_paths[name] = path;
    }
    return path;
  };

  module.exports = function(source) {
    var remaining_request, result;
    this.cachable && this.cachable();
    remaining_request = loader_utils.getRemainingRequest(this);
    result = compile_video(remaining_request);
    if (result) {
      return this.callback(null, result);
    }
  };

}).call(this);
